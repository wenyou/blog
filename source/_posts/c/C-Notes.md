---
title: C语言学习笔记
author: Zeeny
comments: false
date: 2014-05-13
updated: 2014-05-13
tags: [C,C++]
categories: [C,C++]
summary: C语言学习笔记
---

# C语言学习笔记
## 一、参考资源

* [中文版：Linux C/C++编程一站式学习](http://songjinshan.com/akabook/zh/index.html)
* [GDB中应该知道的几个调试方法](http://coolshell.cn/articles/3643.html)
* [如何学好C语言](http://coolshell.cn/articles/4102.html)
* [C语言结构体里的成员数组和指针](http://coolshell.cn/articles/11377.html)
* [无插件Vim编程技巧](http://coolshell.cn/articles/11312.html)

## 二、常用数据类型占用的存储空间

![常用数据类型占用的存储空间](/images/c_data_bype_log.png)
* 注意：char类型是最小的数据类型单位，在任何类型的编译器下都是占用1个字节，char类型的变量赋值可以直接赋值等于某个字符也可以赋值为整数（对应的ASCII值）。

## 三、printf()函数  输出格式符

![输出格式符](/images/printf_format.png)


## 四、小知识总结

### 4.1 静态函数、静态变量

* static修饰的函数（静态函数）只能被本文件里内容使用，不能再外部被调用。
* c语言中，static就有两个作用：一是隐藏功能，对于static修饰的函数和全局变量而言。二是保持持久性功能，对于static修饰的局部变量而言。并且，因为存放在静态区，全局和局部的static修饰的变量，都默认初始化为0。
* 静态函数如果没有人调用，编译器会报告；普通函数就不会报告。
* 在C里面，所谓 static ，只是限制在当前源文件————这个只是对于编译器/链接器而言。但实际上，运行时，static和普通的extern 的函数/变量，没有区别。例如：使用函数指针/变量指针，完全可以访问其他文件的 static 变量/函数。




#### C程序一直由下列部分组成：
​       &emsp;&emsp;1）正文段——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令;
​     &emsp;&emsp; 2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。 
​     &emsp;&emsp; 3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。
​      &emsp;&emsp;4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。      

​      &emsp;&emsp;5）堆——动态存储分。



#### 全局静态变量

​	&emsp;&emsp;在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
​	&emsp;&emsp;__1）内存中的位置：__

​			&emsp;&emsp;&emsp;&emsp;静态存储区（静态存储区在整个程序运行期间都存在）
​	&emsp;&emsp;__2）初始化：__

​			&emsp;&emsp;&emsp;&emsp;未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
​	&emsp;&emsp;__3）作用域：__

​			&emsp;&emsp;&emsp;&emsp;全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。

__好处：__
	&emsp;&emsp;定义全局静态变量的好处：
		&emsp;&emsp;&emsp;&emsp;<1>不会被其他文件所访问，修改;
		&emsp;&emsp;&emsp;&emsp;<2>其他文件中可以使用相同名字的变量，不会发生冲突。



#### 局部静态变量

​	&emsp;&emsp;在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。

__1）内存中的位置：__

​	&emsp;&emsp;静态存储区
__2）初始化：__

​	&emsp;&emsp;未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化） 
__3）作用域：__

​	&emsp;&emsp;作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。



​	&emsp;&emsp;注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
  	
​	&emsp;&emsp;当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。



#### 静态函数

​	&emsp;&emsp;在函数的返回类型前加上关键字static，函数就被定义成为静态函数。
​	&emsp;&emsp;函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

​	___定义静态函数的好处：___
​		&emsp;&emsp;<1> 其他文件中可以定义相同名字的函数，不会发生冲突。
​		&emsp;&emsp;<2> 静态函数不能被其他文件所用。


​	&emsp;&emsp;存储说明符auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。 auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出该程序块时撤销。
​	&emsp;&emsp;关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期（static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。

​	&emsp;&emsp;由于static变量的以上特性，可实现一些特定功能。



​	__统计次数功能__
​	&emsp;&emsp;声明函数的一个局部变量，并设为static类型，作为一个计数器，这样函数每次被调用的时候就可以进行计数。这是统计函数被调用次数的最好的办法，因为这个变量是和函数息息相关的，而函数可能在多个不同的地方被调用，所以从调用者的角度来统计比较困难。
​		

#### 总结一下

​	&emsp;&emsp;C语言中使用静态函数的好处：
​		&emsp;&emsp;&emsp;&emsp;静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
​		&emsp;&emsp;&emsp;&emsp;关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。 使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。

#### C语言中static的语义

##### 1.static变量

__1).局部 __

​	&emsp;&emsp;a. 静态局部变量在函数内定义,生存期为整个源程序，但作用域与自动变量相同，只能在定义该变量的函数内使用。退出该函数后， 尽管该变量还继续存在，但不能使用它。
​	&emsp;&emsp;b.对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。

__2).全局__

​	&emsp;&emsp;全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。

​	&emsp;&emsp;但是他们的作用域，非静态全局变量的作用域是整个源程序（多个源文件可以共同使用）； 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。

##### 2.static函数

​	&emsp;&emsp;static函数（也叫内部函数）只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用。区别于一般的非静态函数（外部函数）。
​	&emsp;&emsp;static在c里面可以用来修饰变量，也可以用来修饰函数。 
​	&emsp;&emsp;先看用来修饰变量的时候。变量在c里面可分为存在全局数据区、栈和堆里。其实我们平时所说的堆栈是栈而不包含堆，不要弄混。




### 4.2 程序的编译过程

```

	(1)、预处理（Pre-Processing）: gcc -E test.c -o test.i
	(2)、编译（Compiling）: gcc -S test.i -o test.s
	(3)、汇编（Assembling）: gcc -c test.s -o test.o
	(4)、链接 (Linking): gcc test.o -o test
	
	简化：
	gcc -c test.c -o test.o
	gcc test.o -o test
	或
	gcc test.c -o test
	
```

### 4.3 函数返回值类型

* 任何基本数据类型 或 指针。
* void 不返回任何值。
* 不能是数组。

### 4.4 extern 关键字

* 一个文件中的程序代码需要使用另外一个文件内定义的全局变量，就要使用extern在当前文件中对该全局变量进行声明。
* 类似的，函数也一样。

### 4.5 数组

* 在所有函数外定义的数组的所有元素将被自动赋予初值0，在函数内部定义的数组，系统不会为其进行初始化，在使用数组元素前必须先对元素进行初始化。
* 字符数组，用来存放字符的一维数组，就是char类型的一维数组。
* 在C中，字符串是用字符数组来存储的。这里要区分字符串长度和字符数组长度。‘\0‘代表一个字符串的结束。

### 4.6 指针

* 区别 int (\*p)[5] 和 int \*p[5]，前者是一个指针，它指向一个含有5个元素的数组。后者是一个数组，它的长度为5，数组中的每一个元素指向一个整型变量。
* int \*p[5]， 运算符\*的优先级低于运算符[]，因此p先与[5]结合，形成p[5]的形式，它显然是一个数组。然后再与\*结合，表示数组元素的类型为指针，每个数组元素都指向一个整形变量。这里的p就是一个二级指针，它是指针的指针。
* 如果一个函数的参数中有指针，那么出于程序健壮性的考虑，在该函数中须检查参数是否为NULL。
* int \*f(int i, int j)，调用该函数后，返回一个指向整形变量的指针。()的优先级要高于\*，因此f先与()结合，这表示f是一个函数。函数名前有一个\*，表示此函数的返回值类型为指针。



